---

## Expr7. Design and Application of Multiplexers

### §1 Purposes & Requirements

1. Master the logic function and logic structure of binary decoder Multiplexer.
2. Learn and master the usage of Multiplexer.
3. Understand the scanning display method for 4 LED digital tube displays.
4. Implement Scoreboard function by using 4 LED display modules.

### §2 Principle & Tasks

#### 2.1 Experiment Tasks

1. Design a Multiplexer.
2. Implement a Scoreboard using the multiplexer.

#### 2.2 Experiment Principle

##### 2.2.1 4-to-1-line Multiplexer: *MUX4to1*

- Simplify the truth table according to the events.

- The output is the **AND-OR Structure** of all the minterms of the *Control Signals* of the MUX (Multiplexer).

  <img src="Expr7/Mux4to1_Prin.png" alt="Mux4to1_Prin" style="zoom:48%;" />

##### 2.2.2 MUX - Bit Extensions

Remain the **Control Structure** of the *MUX4to1* unchanged, make each input signals **Vectors**. (As shown below.)

Function: Select a desired **vector** according to the control signals and output that **vector**.

<img src="Expr7/Mux4to1b4_Prin.png" alt="Mux4to1b4_Prin" style="zoom:48%;" />

##### 2.2.3 Dynamic Scanning Display Method

1. **Dynamic Scanning Display Method**

   - The **scanning signal** comes from the on-board counter -- Convert a timing circuit into a combinational circuit.
   - A *clk* signal can be generated by the on-board clock at a certain frequency (100MHz) which can be used to generate a scanning signal at a desired frequency and use for scanning display of LEDs.
   - The refresh frequency should neither be too high nor too low. It should keep your eyes comfortable (24Hz ~ 144Hz generally).

2. **Implementation by Conditional Statements**

   We can use `if-then` or `case` statements to implement conditional output circuit.
   
   <img src="Expr7/Clk.png" alt="Clk" style="zoom:48%;" />

##### 2.2.4 Use Multiplexers to Display 4 Digits on the 7-Segment Digital Tube Display

1. **Schematic Approach**

   Use `SCAN(1:0)` to control 4 4-to-1-line multiplexers and select `HEX(3:0)` (Digit to be displayed), `p` (Decimal point), `LE` (Low Enable) and `AN(3:0)` (Which 7-segment display to be used). The schematic diagram is shown below (drawn by me myself).

   <img src="Expr7/DisplaySync_sch.PNG" alt="DisplaySync_sch" style="zoom:75%;" />

2. **Coding Approach**

   We can also code to implement the same module, which will be mentioned in a later section.

   ```verilog
   module dispsync(
       input  [15:0] Hexs,    //merge port variables and definition
   	input  [1:0] Scan,
   	input  [3:0] Point,
   	input  [3:0] Les,
   	output reg [3:0] Hex,
   	output reg p,LE,
   	output reg [3:0] AN);
      	
       always @* begin	//signal changes trigger(combinational logic circuits no ctl)	
   		case (Scan)
   	    	2‘b00 : begin Hex <= Hexs[3:0];	AN <= 4’b 1110; …	//Synchronized Output
   	        2'b01 : begin Hex <= Hexs[7:4]; AN <= 4’b 1101; …	//Synchronized Output
               2'b10 : begin Hex <= Hexs[11:8];AN <= 4’b 1011; …	//Synchronized Output
               2'b11 : begin Hex <= Hexs[15:12];AN <= 4’b 0111; …	//Synchronized Output
          	endcase
      	end
   endmodule
   ```

##### 2.2.5 Auxiliary Module: *Count Clock Divider (clkdiv)*

To generate the `Scan` signal, we need a 32-bit Count Clock Divider.

1. It can output $2$ ~ $2^{32}$ divided signals and can also be used in general non-synchronous classes.
2. It can be used in this experiment for multi-digits 7-segment display dynamic scanning.

The implementation of it will be mentioned in a later section.

##### 2.2.6 Auxiliary Module: *disp_num*

Invoke modules *clkdiv*, *DisplaySync* and *MyMC14495* (which was implemented in experiment 6) to display different digits on the 4 7-segment digital tube displays. The I/O of this module is as the following:

```verilog
module disp_num(
	input wire clk, RST,
    input wire [15:0] HEXS,		// Bits for HEX digits
    input wire [3:0] points,	// 4 decimal points
    input wire [3:0] LES,		// 4 LED enable signals
    output reg [3:0] AN,		// Enable 1-out-of-4 asserted low
    output reg [7:0] SEG		// LED segments
)
```

The schematic implementation of it will be mentioned in a later section.

### §3 Main Instruments & Materials

#### 3.1 Experiment Instruments

1. A Computer with ISE 14.7 Installed
2. SWORD Board

#### 3.2 Experiment Materials

None.

### §4 Experiment Procedure & Operations

#### 4.1 Design a 4-to-1-line Multiplexer *Mux4to1b4*

1. Create a new ISE project named "*Mux4to1b4_sch*".

2. Create a new Schematic source file named "*Mux4to1b4.sch*".

3. Design *Mux4to1b4* module by drawing schematic diagram (as the figure below which is drawn by me myself).

<img src="Expr7/Mux4to1b4_sch.png" alt="Mux4to1b4_sch" style="zoom:75%;" />

4. Use "Check Design Rules" in "Design Utilities" to check errors.

5. Run "View HDL Functional Model" to see and learn Verilog HDL code of the design (*MyMC14495* Module).

6. Run simulation on *MyMC14495* Module. Main part of excitation code is as the following:

   ```verilog
   initial begin
       I0 = 4'b0001;
       I1 = 4'b0010;
       I2 = 4'b0100;
       I3 = 4'b1000;
       
       S = 2'b00;
       #50;
       S = 2'b01;
       #50;
       S = 2'b10;
       #50;
       S = 2'b11;
       #50
   end
   ```
7. Click "Create Schematic Symbol" and "View HDL Functional Model" to generate logic symbol diagram and *.vf file* for later use.

#### 4.2 Implement a *Scoreboard* using the multiplexer

1. Create new ISE Project named "*ScoreBoard*" with **"Top Level Source Type" HDL** (The second project).

2. Create new Schematic source file named "*DisplaySync.sch*". Design the dynamic scanning synchronization output module *DisplaySync* according to the principle. The schematic diagram is as shown below (which was drawn by me myself):

   <img src="Expr7/DisplaySync_sch.PNG" alt="DisplaySync_sch" style="zoom:75%;" />

3. Create new Verilog HDL Source File "*clkdiv.v*". Design the **Universal Count Clock Divider** Module *clkdiv* (which will be used in later projects) according to the principle. The implementation code is as the following:

   **Note:** You can use "Check Syntax" function anytime to check if your design is grammatically correct. 

   ```verilog
   module clkdiv(
   	input clk,
       input rst,
       output reg [31:0] clkdiv
   );
       always @ (posedge clk or posedge rst) begin
           if (rst) clkdiv <= 0;
           else clkdiv <= clkdiv + 1'b1;
       end
   endmodule
   ```

4. Create symbols of *DisplaySync* and *clkdiv* modules for later use.

5. Create new Schematic source file "*disp_num.sch*" and design the display module by drawing schematic as the following (which was drawn by me myself):

   <img src="Expr7/DispNum_sch.PNG" alt="DispNum_sch" style="zoom:75%;" />

6. Create new Verilog HDL Source File "*CreateNumber.v*" and design the Button Data Input Module for our Scoreboard. The code of it is as the following.

   **Function:** Allow pressing 4 different buttons to make the 4 numbers displayed increased by 1 respectively.

   ```verilog
   module CreateNumber(
   	input wire [3:0] btn,
   	output reg [15:0] num
   	);
   	wire [3:0] A,B,C,D;
   	
   	initial num <= 16'b1010_1011_1100_1101;		// Display "AbCd" as initialization.
   	
       assign A = num[3:0]   + 4'd1;	// Whenever num[3:0] changes, make A = num[3:0]+1.
   	assign B = num[7:4]   + 4'd1;
   	assign C = num[11:8]  + 4'd1;
   	assign D = num[15:12] + 4'd1;
   	
       // Assign A to num[3:0] when btn[0] is pressed.
       always @ (posedge btn[0]) num[3:0]   <= A;	
   	always @ (posedge btn[1]) num[7:4]   <= B;
   	always @ (posedge btn[2]) num[11:8]  <= C;
   	always @ (posedge btn[3]) num[15:12] <= D;
   
   endmodule
   ```

7. Create new Verilog HDL Source File "*Top.v*", right click on it and set it as the **Top Module**. Invoke *CreateNumber* and *disp_num* modules to implement the scoreboard function. The code of this module is as the following.

   **Note:** "Top Module" is something like `main()` function in a C program. It marks the "entry" of the project and it's where the whole project start.

   ```verilog
   module top(
   	input wire clk,
       input wire [7:0] SW,
       input wire [3:0] btn,
       output wire [3:0] AN,
       output wire [7:0] SEG
   	);
       wire [15:0] num;
   	
   	CreateNumber c0(btn, num);
   	
   	disp_num d0(clk, num, SW[7:4], SW[3:0], 1'b0, AN, SEG);
   
   endmodule
   ```

8. Upload the design to the SWORD Board and verify the function of our *ScoreBoard*. The User Constraint File (UCF) is as the following:

   ![Constraint](Expr7/Constraint.PNG)

   **Note:** I used switches instead of buttons to control the increase of the 4 numbers (Line 3~10). What's more, the statement `clock_dedicated_route = false` is necessary to make the change of the `btn` instant.

9. The correspondence of the I/O and  the Pins can be seen in "Pinout Report" in "Design Summary".

10. Operate on the SWORD Board according to the truth table to verify whether the module implemented the target function.

### §5 Results & Analysis

#### 5.1 Design a 4-to-1-line Multiplexer *Mux4to1b4*

1. "Check Design Rules" didn't return any errors.

2. Simulation result was as the following:

   ![Mux4to1b4_sim](Expr7/Mux4to1b4_sim.png)

3. The generated symbol of *Mux4to1b4* Module was as the following:

   **Note:** Organize the order and modify names of the pins of user-generated symbols properly (like this one below) may be significantly helpful (in avoiding bugs) when you use it in a complex circuit.

   ![Mux4to1b4_sym](Expr7/Mux4to1b4_sym.PNG)

**Analysis:** From the simulation diagram, we can see that the *Mux4to1b4* Module implemented the desired function.

#### 5.2 Implement a *Scoreboard* using the multiplexer

1. The generated *DisplaySync* symbol is as shown in the figure below.

   <img src="Expr7/DisplaySync_sym.PNG" alt="DisplaySync_sym" style="zoom:75%;" />

2. The generated *clkdiv* symbol is as shown in the figure below.

   <img src="Expr7/clkdiv_sym.PNG" alt="clkdiv_sym" style="zoom:75%;" />

3. All "Check Syntax" didn't return any error.

4. I used switches instead of buttons to control the increase of the 4 numbers. After modifying user constraint file, the correspondence of the I/O and the Pins (Pinout Report) is as shown in the following figure.

   ![PinoutRepo](Expr7/PinoutRepo.png)

5. After operating on the SWORD Board, it was clear that the *MyMC14495 Decoder Module* worked correctly on the board. All input combinations and outputs satisfied the truth table.


**Analysis:** So far, the desired function of this experiment, which was to design a scoreboard, is correctly implemented by using 4-to-1-line multiplexers *"Mux4to1b4"* and relative display components. The experiment was successful.

## §6 Overall Discussion & Experience

I've learnt something different in this part of the lab course.

**For professional knowledge**, I learnt about the principle and implemented Binary Decoders, Display Decoders and Multiplexers, with which I even designed some useful function blocks such as *LampCtrl138* using a 3-to-8-line binary decoder, *DispNumber* using a display decoder, and *ScoreBoard* using a 4-to-1-line multiplexer along with other auxiliary modules. I've truly learnt a lot about Logic & Computer Design and get more familiar with the ISE Platform.

**For experience gained**, I have to say that, honestly, I was always very confused and didn't have a clue what I should do when I first opened the keynotes of an experiment. Nevertheless, with the confidence where I believed I could figure it out, I finally got through and understood all of the contents and the outcome turned out to be successful. This really gave me a sense of achievement and surely contributed to my self-confidence.

And I've also learnt something new all the way **through the process of writing this report**. I found a more convenient software for writing, got more proficient in the writing process, and needless to say, learnt a bunch of new terminologies. 

## §7 Personal Image

According to the requirement of this report, the following is a photo of me.

<img src="Expr7/DSC_4071.jpg" alt="DSC_4071" style="zoom:15%;" />